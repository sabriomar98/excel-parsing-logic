
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `InstructionVersion` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model InstructionVersion
 * 
 */
export type InstructionVersionModel = runtime.Types.Result.DefaultSelection<Prisma.$InstructionVersionPayload>

export type AggregateInstructionVersion = {
  _count: InstructionVersionCountAggregateOutputType | null
  _avg: InstructionVersionAvgAggregateOutputType | null
  _sum: InstructionVersionSumAggregateOutputType | null
  _min: InstructionVersionMinAggregateOutputType | null
  _max: InstructionVersionMaxAggregateOutputType | null
}

export type InstructionVersionAvgAggregateOutputType = {
  versionNumber: number | null
  chargeTotale: number | null
}

export type InstructionVersionSumAggregateOutputType = {
  versionNumber: number | null
  chargeTotale: number | null
}

export type InstructionVersionMinAggregateOutputType = {
  id: string | null
  projectId: string | null
  versionNumber: number | null
  fileHash: string | null
  fileName: string | null
  filePath: string | null
  demandeur: string | null
  chargeTotale: number | null
  dateDebut: Date | null
  dateMEP: Date | null
  dateValidation: Date | null
  status: string | null
  imputedBy: string | null
  uploadedBy: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type InstructionVersionMaxAggregateOutputType = {
  id: string | null
  projectId: string | null
  versionNumber: number | null
  fileHash: string | null
  fileName: string | null
  filePath: string | null
  demandeur: string | null
  chargeTotale: number | null
  dateDebut: Date | null
  dateMEP: Date | null
  dateValidation: Date | null
  status: string | null
  imputedBy: string | null
  uploadedBy: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type InstructionVersionCountAggregateOutputType = {
  id: number
  projectId: number
  versionNumber: number
  fileHash: number
  fileName: number
  filePath: number
  demandeur: number
  chargeTotale: number
  dateDebut: number
  dateMEP: number
  dateValidation: number
  status: number
  imputedBy: number
  uploadedBy: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type InstructionVersionAvgAggregateInputType = {
  versionNumber?: true
  chargeTotale?: true
}

export type InstructionVersionSumAggregateInputType = {
  versionNumber?: true
  chargeTotale?: true
}

export type InstructionVersionMinAggregateInputType = {
  id?: true
  projectId?: true
  versionNumber?: true
  fileHash?: true
  fileName?: true
  filePath?: true
  demandeur?: true
  chargeTotale?: true
  dateDebut?: true
  dateMEP?: true
  dateValidation?: true
  status?: true
  imputedBy?: true
  uploadedBy?: true
  createdAt?: true
  updatedAt?: true
}

export type InstructionVersionMaxAggregateInputType = {
  id?: true
  projectId?: true
  versionNumber?: true
  fileHash?: true
  fileName?: true
  filePath?: true
  demandeur?: true
  chargeTotale?: true
  dateDebut?: true
  dateMEP?: true
  dateValidation?: true
  status?: true
  imputedBy?: true
  uploadedBy?: true
  createdAt?: true
  updatedAt?: true
}

export type InstructionVersionCountAggregateInputType = {
  id?: true
  projectId?: true
  versionNumber?: true
  fileHash?: true
  fileName?: true
  filePath?: true
  demandeur?: true
  chargeTotale?: true
  dateDebut?: true
  dateMEP?: true
  dateValidation?: true
  status?: true
  imputedBy?: true
  uploadedBy?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type InstructionVersionAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which InstructionVersion to aggregate.
   */
  where?: Prisma.InstructionVersionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of InstructionVersions to fetch.
   */
  orderBy?: Prisma.InstructionVersionOrderByWithRelationInput | Prisma.InstructionVersionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.InstructionVersionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` InstructionVersions from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` InstructionVersions.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned InstructionVersions
  **/
  _count?: true | InstructionVersionCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: InstructionVersionAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: InstructionVersionSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: InstructionVersionMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: InstructionVersionMaxAggregateInputType
}

export type GetInstructionVersionAggregateType<T extends InstructionVersionAggregateArgs> = {
      [P in keyof T & keyof AggregateInstructionVersion]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateInstructionVersion[P]>
    : Prisma.GetScalarType<T[P], AggregateInstructionVersion[P]>
}




export type InstructionVersionGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.InstructionVersionWhereInput
  orderBy?: Prisma.InstructionVersionOrderByWithAggregationInput | Prisma.InstructionVersionOrderByWithAggregationInput[]
  by: Prisma.InstructionVersionScalarFieldEnum[] | Prisma.InstructionVersionScalarFieldEnum
  having?: Prisma.InstructionVersionScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: InstructionVersionCountAggregateInputType | true
  _avg?: InstructionVersionAvgAggregateInputType
  _sum?: InstructionVersionSumAggregateInputType
  _min?: InstructionVersionMinAggregateInputType
  _max?: InstructionVersionMaxAggregateInputType
}

export type InstructionVersionGroupByOutputType = {
  id: string
  projectId: string
  versionNumber: number
  fileHash: string
  fileName: string
  filePath: string
  demandeur: string | null
  chargeTotale: number
  dateDebut: Date | null
  dateMEP: Date | null
  dateValidation: Date | null
  status: string
  imputedBy: string | null
  uploadedBy: string
  createdAt: Date
  updatedAt: Date
  _count: InstructionVersionCountAggregateOutputType | null
  _avg: InstructionVersionAvgAggregateOutputType | null
  _sum: InstructionVersionSumAggregateOutputType | null
  _min: InstructionVersionMinAggregateOutputType | null
  _max: InstructionVersionMaxAggregateOutputType | null
}

type GetInstructionVersionGroupByPayload<T extends InstructionVersionGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<InstructionVersionGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof InstructionVersionGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], InstructionVersionGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], InstructionVersionGroupByOutputType[P]>
      }
    >
  >



export type InstructionVersionWhereInput = {
  AND?: Prisma.InstructionVersionWhereInput | Prisma.InstructionVersionWhereInput[]
  OR?: Prisma.InstructionVersionWhereInput[]
  NOT?: Prisma.InstructionVersionWhereInput | Prisma.InstructionVersionWhereInput[]
  id?: Prisma.StringFilter<"InstructionVersion"> | string
  projectId?: Prisma.StringFilter<"InstructionVersion"> | string
  versionNumber?: Prisma.IntFilter<"InstructionVersion"> | number
  fileHash?: Prisma.StringFilter<"InstructionVersion"> | string
  fileName?: Prisma.StringFilter<"InstructionVersion"> | string
  filePath?: Prisma.StringFilter<"InstructionVersion"> | string
  demandeur?: Prisma.StringNullableFilter<"InstructionVersion"> | string | null
  chargeTotale?: Prisma.FloatFilter<"InstructionVersion"> | number
  dateDebut?: Prisma.DateTimeNullableFilter<"InstructionVersion"> | Date | string | null
  dateMEP?: Prisma.DateTimeNullableFilter<"InstructionVersion"> | Date | string | null
  dateValidation?: Prisma.DateTimeNullableFilter<"InstructionVersion"> | Date | string | null
  status?: Prisma.StringFilter<"InstructionVersion"> | string
  imputedBy?: Prisma.StringNullableFilter<"InstructionVersion"> | string | null
  uploadedBy?: Prisma.StringFilter<"InstructionVersion"> | string
  createdAt?: Prisma.DateTimeFilter<"InstructionVersion"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"InstructionVersion"> | Date | string
  project?: Prisma.XOR<Prisma.ProjectScalarRelationFilter, Prisma.ProjectWhereInput>
  collaborators?: Prisma.CollaboratorLineListRelationFilter
  plannings?: Prisma.PlanningLineListRelationFilter
  uploadedByUser?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
}

export type InstructionVersionOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  projectId?: Prisma.SortOrder
  versionNumber?: Prisma.SortOrder
  fileHash?: Prisma.SortOrder
  fileName?: Prisma.SortOrder
  filePath?: Prisma.SortOrder
  demandeur?: Prisma.SortOrderInput | Prisma.SortOrder
  chargeTotale?: Prisma.SortOrder
  dateDebut?: Prisma.SortOrderInput | Prisma.SortOrder
  dateMEP?: Prisma.SortOrderInput | Prisma.SortOrder
  dateValidation?: Prisma.SortOrderInput | Prisma.SortOrder
  status?: Prisma.SortOrder
  imputedBy?: Prisma.SortOrderInput | Prisma.SortOrder
  uploadedBy?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  project?: Prisma.ProjectOrderByWithRelationInput
  collaborators?: Prisma.CollaboratorLineOrderByRelationAggregateInput
  plannings?: Prisma.PlanningLineOrderByRelationAggregateInput
  uploadedByUser?: Prisma.UserOrderByWithRelationInput
}

export type InstructionVersionWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  fileHash?: string
  projectId_versionNumber?: Prisma.InstructionVersionProjectIdVersionNumberCompoundUniqueInput
  AND?: Prisma.InstructionVersionWhereInput | Prisma.InstructionVersionWhereInput[]
  OR?: Prisma.InstructionVersionWhereInput[]
  NOT?: Prisma.InstructionVersionWhereInput | Prisma.InstructionVersionWhereInput[]
  projectId?: Prisma.StringFilter<"InstructionVersion"> | string
  versionNumber?: Prisma.IntFilter<"InstructionVersion"> | number
  fileName?: Prisma.StringFilter<"InstructionVersion"> | string
  filePath?: Prisma.StringFilter<"InstructionVersion"> | string
  demandeur?: Prisma.StringNullableFilter<"InstructionVersion"> | string | null
  chargeTotale?: Prisma.FloatFilter<"InstructionVersion"> | number
  dateDebut?: Prisma.DateTimeNullableFilter<"InstructionVersion"> | Date | string | null
  dateMEP?: Prisma.DateTimeNullableFilter<"InstructionVersion"> | Date | string | null
  dateValidation?: Prisma.DateTimeNullableFilter<"InstructionVersion"> | Date | string | null
  status?: Prisma.StringFilter<"InstructionVersion"> | string
  imputedBy?: Prisma.StringNullableFilter<"InstructionVersion"> | string | null
  uploadedBy?: Prisma.StringFilter<"InstructionVersion"> | string
  createdAt?: Prisma.DateTimeFilter<"InstructionVersion"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"InstructionVersion"> | Date | string
  project?: Prisma.XOR<Prisma.ProjectScalarRelationFilter, Prisma.ProjectWhereInput>
  collaborators?: Prisma.CollaboratorLineListRelationFilter
  plannings?: Prisma.PlanningLineListRelationFilter
  uploadedByUser?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
}, "id" | "fileHash" | "projectId_versionNumber">

export type InstructionVersionOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  projectId?: Prisma.SortOrder
  versionNumber?: Prisma.SortOrder
  fileHash?: Prisma.SortOrder
  fileName?: Prisma.SortOrder
  filePath?: Prisma.SortOrder
  demandeur?: Prisma.SortOrderInput | Prisma.SortOrder
  chargeTotale?: Prisma.SortOrder
  dateDebut?: Prisma.SortOrderInput | Prisma.SortOrder
  dateMEP?: Prisma.SortOrderInput | Prisma.SortOrder
  dateValidation?: Prisma.SortOrderInput | Prisma.SortOrder
  status?: Prisma.SortOrder
  imputedBy?: Prisma.SortOrderInput | Prisma.SortOrder
  uploadedBy?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.InstructionVersionCountOrderByAggregateInput
  _avg?: Prisma.InstructionVersionAvgOrderByAggregateInput
  _max?: Prisma.InstructionVersionMaxOrderByAggregateInput
  _min?: Prisma.InstructionVersionMinOrderByAggregateInput
  _sum?: Prisma.InstructionVersionSumOrderByAggregateInput
}

export type InstructionVersionScalarWhereWithAggregatesInput = {
  AND?: Prisma.InstructionVersionScalarWhereWithAggregatesInput | Prisma.InstructionVersionScalarWhereWithAggregatesInput[]
  OR?: Prisma.InstructionVersionScalarWhereWithAggregatesInput[]
  NOT?: Prisma.InstructionVersionScalarWhereWithAggregatesInput | Prisma.InstructionVersionScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"InstructionVersion"> | string
  projectId?: Prisma.StringWithAggregatesFilter<"InstructionVersion"> | string
  versionNumber?: Prisma.IntWithAggregatesFilter<"InstructionVersion"> | number
  fileHash?: Prisma.StringWithAggregatesFilter<"InstructionVersion"> | string
  fileName?: Prisma.StringWithAggregatesFilter<"InstructionVersion"> | string
  filePath?: Prisma.StringWithAggregatesFilter<"InstructionVersion"> | string
  demandeur?: Prisma.StringNullableWithAggregatesFilter<"InstructionVersion"> | string | null
  chargeTotale?: Prisma.FloatWithAggregatesFilter<"InstructionVersion"> | number
  dateDebut?: Prisma.DateTimeNullableWithAggregatesFilter<"InstructionVersion"> | Date | string | null
  dateMEP?: Prisma.DateTimeNullableWithAggregatesFilter<"InstructionVersion"> | Date | string | null
  dateValidation?: Prisma.DateTimeNullableWithAggregatesFilter<"InstructionVersion"> | Date | string | null
  status?: Prisma.StringWithAggregatesFilter<"InstructionVersion"> | string
  imputedBy?: Prisma.StringNullableWithAggregatesFilter<"InstructionVersion"> | string | null
  uploadedBy?: Prisma.StringWithAggregatesFilter<"InstructionVersion"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"InstructionVersion"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"InstructionVersion"> | Date | string
}

export type InstructionVersionCreateInput = {
  id?: string
  versionNumber?: number
  fileHash: string
  fileName: string
  filePath: string
  demandeur?: string | null
  chargeTotale: number
  dateDebut?: Date | string | null
  dateMEP?: Date | string | null
  dateValidation?: Date | string | null
  status?: string
  imputedBy?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  project: Prisma.ProjectCreateNestedOneWithoutVersionsInput
  collaborators?: Prisma.CollaboratorLineCreateNestedManyWithoutVersionInput
  plannings?: Prisma.PlanningLineCreateNestedManyWithoutVersionInput
  uploadedByUser: Prisma.UserCreateNestedOneWithoutUploadedVersionsInput
}

export type InstructionVersionUncheckedCreateInput = {
  id?: string
  projectId: string
  versionNumber?: number
  fileHash: string
  fileName: string
  filePath: string
  demandeur?: string | null
  chargeTotale: number
  dateDebut?: Date | string | null
  dateMEP?: Date | string | null
  dateValidation?: Date | string | null
  status?: string
  imputedBy?: string | null
  uploadedBy: string
  createdAt?: Date | string
  updatedAt?: Date | string
  collaborators?: Prisma.CollaboratorLineUncheckedCreateNestedManyWithoutVersionInput
  plannings?: Prisma.PlanningLineUncheckedCreateNestedManyWithoutVersionInput
}

export type InstructionVersionUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  versionNumber?: Prisma.IntFieldUpdateOperationsInput | number
  fileHash?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  filePath?: Prisma.StringFieldUpdateOperationsInput | string
  demandeur?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  chargeTotale?: Prisma.FloatFieldUpdateOperationsInput | number
  dateDebut?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateMEP?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateValidation?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  imputedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  project?: Prisma.ProjectUpdateOneRequiredWithoutVersionsNestedInput
  collaborators?: Prisma.CollaboratorLineUpdateManyWithoutVersionNestedInput
  plannings?: Prisma.PlanningLineUpdateManyWithoutVersionNestedInput
  uploadedByUser?: Prisma.UserUpdateOneRequiredWithoutUploadedVersionsNestedInput
}

export type InstructionVersionUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  projectId?: Prisma.StringFieldUpdateOperationsInput | string
  versionNumber?: Prisma.IntFieldUpdateOperationsInput | number
  fileHash?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  filePath?: Prisma.StringFieldUpdateOperationsInput | string
  demandeur?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  chargeTotale?: Prisma.FloatFieldUpdateOperationsInput | number
  dateDebut?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateMEP?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateValidation?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  imputedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  uploadedBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  collaborators?: Prisma.CollaboratorLineUncheckedUpdateManyWithoutVersionNestedInput
  plannings?: Prisma.PlanningLineUncheckedUpdateManyWithoutVersionNestedInput
}

export type InstructionVersionCreateManyInput = {
  id?: string
  projectId: string
  versionNumber?: number
  fileHash: string
  fileName: string
  filePath: string
  demandeur?: string | null
  chargeTotale: number
  dateDebut?: Date | string | null
  dateMEP?: Date | string | null
  dateValidation?: Date | string | null
  status?: string
  imputedBy?: string | null
  uploadedBy: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type InstructionVersionUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  versionNumber?: Prisma.IntFieldUpdateOperationsInput | number
  fileHash?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  filePath?: Prisma.StringFieldUpdateOperationsInput | string
  demandeur?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  chargeTotale?: Prisma.FloatFieldUpdateOperationsInput | number
  dateDebut?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateMEP?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateValidation?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  imputedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type InstructionVersionUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  projectId?: Prisma.StringFieldUpdateOperationsInput | string
  versionNumber?: Prisma.IntFieldUpdateOperationsInput | number
  fileHash?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  filePath?: Prisma.StringFieldUpdateOperationsInput | string
  demandeur?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  chargeTotale?: Prisma.FloatFieldUpdateOperationsInput | number
  dateDebut?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateMEP?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateValidation?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  imputedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  uploadedBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type InstructionVersionListRelationFilter = {
  every?: Prisma.InstructionVersionWhereInput
  some?: Prisma.InstructionVersionWhereInput
  none?: Prisma.InstructionVersionWhereInput
}

export type InstructionVersionOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type InstructionVersionProjectIdVersionNumberCompoundUniqueInput = {
  projectId: string
  versionNumber: number
}

export type InstructionVersionCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  projectId?: Prisma.SortOrder
  versionNumber?: Prisma.SortOrder
  fileHash?: Prisma.SortOrder
  fileName?: Prisma.SortOrder
  filePath?: Prisma.SortOrder
  demandeur?: Prisma.SortOrder
  chargeTotale?: Prisma.SortOrder
  dateDebut?: Prisma.SortOrder
  dateMEP?: Prisma.SortOrder
  dateValidation?: Prisma.SortOrder
  status?: Prisma.SortOrder
  imputedBy?: Prisma.SortOrder
  uploadedBy?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type InstructionVersionAvgOrderByAggregateInput = {
  versionNumber?: Prisma.SortOrder
  chargeTotale?: Prisma.SortOrder
}

export type InstructionVersionMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  projectId?: Prisma.SortOrder
  versionNumber?: Prisma.SortOrder
  fileHash?: Prisma.SortOrder
  fileName?: Prisma.SortOrder
  filePath?: Prisma.SortOrder
  demandeur?: Prisma.SortOrder
  chargeTotale?: Prisma.SortOrder
  dateDebut?: Prisma.SortOrder
  dateMEP?: Prisma.SortOrder
  dateValidation?: Prisma.SortOrder
  status?: Prisma.SortOrder
  imputedBy?: Prisma.SortOrder
  uploadedBy?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type InstructionVersionMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  projectId?: Prisma.SortOrder
  versionNumber?: Prisma.SortOrder
  fileHash?: Prisma.SortOrder
  fileName?: Prisma.SortOrder
  filePath?: Prisma.SortOrder
  demandeur?: Prisma.SortOrder
  chargeTotale?: Prisma.SortOrder
  dateDebut?: Prisma.SortOrder
  dateMEP?: Prisma.SortOrder
  dateValidation?: Prisma.SortOrder
  status?: Prisma.SortOrder
  imputedBy?: Prisma.SortOrder
  uploadedBy?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type InstructionVersionSumOrderByAggregateInput = {
  versionNumber?: Prisma.SortOrder
  chargeTotale?: Prisma.SortOrder
}

export type InstructionVersionScalarRelationFilter = {
  is?: Prisma.InstructionVersionWhereInput
  isNot?: Prisma.InstructionVersionWhereInput
}

export type InstructionVersionCreateNestedManyWithoutUploadedByUserInput = {
  create?: Prisma.XOR<Prisma.InstructionVersionCreateWithoutUploadedByUserInput, Prisma.InstructionVersionUncheckedCreateWithoutUploadedByUserInput> | Prisma.InstructionVersionCreateWithoutUploadedByUserInput[] | Prisma.InstructionVersionUncheckedCreateWithoutUploadedByUserInput[]
  connectOrCreate?: Prisma.InstructionVersionCreateOrConnectWithoutUploadedByUserInput | Prisma.InstructionVersionCreateOrConnectWithoutUploadedByUserInput[]
  createMany?: Prisma.InstructionVersionCreateManyUploadedByUserInputEnvelope
  connect?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
}

export type InstructionVersionUncheckedCreateNestedManyWithoutUploadedByUserInput = {
  create?: Prisma.XOR<Prisma.InstructionVersionCreateWithoutUploadedByUserInput, Prisma.InstructionVersionUncheckedCreateWithoutUploadedByUserInput> | Prisma.InstructionVersionCreateWithoutUploadedByUserInput[] | Prisma.InstructionVersionUncheckedCreateWithoutUploadedByUserInput[]
  connectOrCreate?: Prisma.InstructionVersionCreateOrConnectWithoutUploadedByUserInput | Prisma.InstructionVersionCreateOrConnectWithoutUploadedByUserInput[]
  createMany?: Prisma.InstructionVersionCreateManyUploadedByUserInputEnvelope
  connect?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
}

export type InstructionVersionUpdateManyWithoutUploadedByUserNestedInput = {
  create?: Prisma.XOR<Prisma.InstructionVersionCreateWithoutUploadedByUserInput, Prisma.InstructionVersionUncheckedCreateWithoutUploadedByUserInput> | Prisma.InstructionVersionCreateWithoutUploadedByUserInput[] | Prisma.InstructionVersionUncheckedCreateWithoutUploadedByUserInput[]
  connectOrCreate?: Prisma.InstructionVersionCreateOrConnectWithoutUploadedByUserInput | Prisma.InstructionVersionCreateOrConnectWithoutUploadedByUserInput[]
  upsert?: Prisma.InstructionVersionUpsertWithWhereUniqueWithoutUploadedByUserInput | Prisma.InstructionVersionUpsertWithWhereUniqueWithoutUploadedByUserInput[]
  createMany?: Prisma.InstructionVersionCreateManyUploadedByUserInputEnvelope
  set?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
  disconnect?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
  delete?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
  connect?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
  update?: Prisma.InstructionVersionUpdateWithWhereUniqueWithoutUploadedByUserInput | Prisma.InstructionVersionUpdateWithWhereUniqueWithoutUploadedByUserInput[]
  updateMany?: Prisma.InstructionVersionUpdateManyWithWhereWithoutUploadedByUserInput | Prisma.InstructionVersionUpdateManyWithWhereWithoutUploadedByUserInput[]
  deleteMany?: Prisma.InstructionVersionScalarWhereInput | Prisma.InstructionVersionScalarWhereInput[]
}

export type InstructionVersionUncheckedUpdateManyWithoutUploadedByUserNestedInput = {
  create?: Prisma.XOR<Prisma.InstructionVersionCreateWithoutUploadedByUserInput, Prisma.InstructionVersionUncheckedCreateWithoutUploadedByUserInput> | Prisma.InstructionVersionCreateWithoutUploadedByUserInput[] | Prisma.InstructionVersionUncheckedCreateWithoutUploadedByUserInput[]
  connectOrCreate?: Prisma.InstructionVersionCreateOrConnectWithoutUploadedByUserInput | Prisma.InstructionVersionCreateOrConnectWithoutUploadedByUserInput[]
  upsert?: Prisma.InstructionVersionUpsertWithWhereUniqueWithoutUploadedByUserInput | Prisma.InstructionVersionUpsertWithWhereUniqueWithoutUploadedByUserInput[]
  createMany?: Prisma.InstructionVersionCreateManyUploadedByUserInputEnvelope
  set?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
  disconnect?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
  delete?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
  connect?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
  update?: Prisma.InstructionVersionUpdateWithWhereUniqueWithoutUploadedByUserInput | Prisma.InstructionVersionUpdateWithWhereUniqueWithoutUploadedByUserInput[]
  updateMany?: Prisma.InstructionVersionUpdateManyWithWhereWithoutUploadedByUserInput | Prisma.InstructionVersionUpdateManyWithWhereWithoutUploadedByUserInput[]
  deleteMany?: Prisma.InstructionVersionScalarWhereInput | Prisma.InstructionVersionScalarWhereInput[]
}

export type InstructionVersionCreateNestedManyWithoutProjectInput = {
  create?: Prisma.XOR<Prisma.InstructionVersionCreateWithoutProjectInput, Prisma.InstructionVersionUncheckedCreateWithoutProjectInput> | Prisma.InstructionVersionCreateWithoutProjectInput[] | Prisma.InstructionVersionUncheckedCreateWithoutProjectInput[]
  connectOrCreate?: Prisma.InstructionVersionCreateOrConnectWithoutProjectInput | Prisma.InstructionVersionCreateOrConnectWithoutProjectInput[]
  createMany?: Prisma.InstructionVersionCreateManyProjectInputEnvelope
  connect?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
}

export type InstructionVersionUncheckedCreateNestedManyWithoutProjectInput = {
  create?: Prisma.XOR<Prisma.InstructionVersionCreateWithoutProjectInput, Prisma.InstructionVersionUncheckedCreateWithoutProjectInput> | Prisma.InstructionVersionCreateWithoutProjectInput[] | Prisma.InstructionVersionUncheckedCreateWithoutProjectInput[]
  connectOrCreate?: Prisma.InstructionVersionCreateOrConnectWithoutProjectInput | Prisma.InstructionVersionCreateOrConnectWithoutProjectInput[]
  createMany?: Prisma.InstructionVersionCreateManyProjectInputEnvelope
  connect?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
}

export type InstructionVersionUpdateManyWithoutProjectNestedInput = {
  create?: Prisma.XOR<Prisma.InstructionVersionCreateWithoutProjectInput, Prisma.InstructionVersionUncheckedCreateWithoutProjectInput> | Prisma.InstructionVersionCreateWithoutProjectInput[] | Prisma.InstructionVersionUncheckedCreateWithoutProjectInput[]
  connectOrCreate?: Prisma.InstructionVersionCreateOrConnectWithoutProjectInput | Prisma.InstructionVersionCreateOrConnectWithoutProjectInput[]
  upsert?: Prisma.InstructionVersionUpsertWithWhereUniqueWithoutProjectInput | Prisma.InstructionVersionUpsertWithWhereUniqueWithoutProjectInput[]
  createMany?: Prisma.InstructionVersionCreateManyProjectInputEnvelope
  set?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
  disconnect?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
  delete?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
  connect?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
  update?: Prisma.InstructionVersionUpdateWithWhereUniqueWithoutProjectInput | Prisma.InstructionVersionUpdateWithWhereUniqueWithoutProjectInput[]
  updateMany?: Prisma.InstructionVersionUpdateManyWithWhereWithoutProjectInput | Prisma.InstructionVersionUpdateManyWithWhereWithoutProjectInput[]
  deleteMany?: Prisma.InstructionVersionScalarWhereInput | Prisma.InstructionVersionScalarWhereInput[]
}

export type InstructionVersionUncheckedUpdateManyWithoutProjectNestedInput = {
  create?: Prisma.XOR<Prisma.InstructionVersionCreateWithoutProjectInput, Prisma.InstructionVersionUncheckedCreateWithoutProjectInput> | Prisma.InstructionVersionCreateWithoutProjectInput[] | Prisma.InstructionVersionUncheckedCreateWithoutProjectInput[]
  connectOrCreate?: Prisma.InstructionVersionCreateOrConnectWithoutProjectInput | Prisma.InstructionVersionCreateOrConnectWithoutProjectInput[]
  upsert?: Prisma.InstructionVersionUpsertWithWhereUniqueWithoutProjectInput | Prisma.InstructionVersionUpsertWithWhereUniqueWithoutProjectInput[]
  createMany?: Prisma.InstructionVersionCreateManyProjectInputEnvelope
  set?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
  disconnect?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
  delete?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
  connect?: Prisma.InstructionVersionWhereUniqueInput | Prisma.InstructionVersionWhereUniqueInput[]
  update?: Prisma.InstructionVersionUpdateWithWhereUniqueWithoutProjectInput | Prisma.InstructionVersionUpdateWithWhereUniqueWithoutProjectInput[]
  updateMany?: Prisma.InstructionVersionUpdateManyWithWhereWithoutProjectInput | Prisma.InstructionVersionUpdateManyWithWhereWithoutProjectInput[]
  deleteMany?: Prisma.InstructionVersionScalarWhereInput | Prisma.InstructionVersionScalarWhereInput[]
}

export type IntFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type FloatFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type NullableDateTimeFieldUpdateOperationsInput = {
  set?: Date | string | null
}

export type InstructionVersionCreateNestedOneWithoutCollaboratorsInput = {
  create?: Prisma.XOR<Prisma.InstructionVersionCreateWithoutCollaboratorsInput, Prisma.InstructionVersionUncheckedCreateWithoutCollaboratorsInput>
  connectOrCreate?: Prisma.InstructionVersionCreateOrConnectWithoutCollaboratorsInput
  connect?: Prisma.InstructionVersionWhereUniqueInput
}

export type InstructionVersionUpdateOneRequiredWithoutCollaboratorsNestedInput = {
  create?: Prisma.XOR<Prisma.InstructionVersionCreateWithoutCollaboratorsInput, Prisma.InstructionVersionUncheckedCreateWithoutCollaboratorsInput>
  connectOrCreate?: Prisma.InstructionVersionCreateOrConnectWithoutCollaboratorsInput
  upsert?: Prisma.InstructionVersionUpsertWithoutCollaboratorsInput
  connect?: Prisma.InstructionVersionWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.InstructionVersionUpdateToOneWithWhereWithoutCollaboratorsInput, Prisma.InstructionVersionUpdateWithoutCollaboratorsInput>, Prisma.InstructionVersionUncheckedUpdateWithoutCollaboratorsInput>
}

export type InstructionVersionCreateNestedOneWithoutPlanningsInput = {
  create?: Prisma.XOR<Prisma.InstructionVersionCreateWithoutPlanningsInput, Prisma.InstructionVersionUncheckedCreateWithoutPlanningsInput>
  connectOrCreate?: Prisma.InstructionVersionCreateOrConnectWithoutPlanningsInput
  connect?: Prisma.InstructionVersionWhereUniqueInput
}

export type InstructionVersionUpdateOneRequiredWithoutPlanningsNestedInput = {
  create?: Prisma.XOR<Prisma.InstructionVersionCreateWithoutPlanningsInput, Prisma.InstructionVersionUncheckedCreateWithoutPlanningsInput>
  connectOrCreate?: Prisma.InstructionVersionCreateOrConnectWithoutPlanningsInput
  upsert?: Prisma.InstructionVersionUpsertWithoutPlanningsInput
  connect?: Prisma.InstructionVersionWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.InstructionVersionUpdateToOneWithWhereWithoutPlanningsInput, Prisma.InstructionVersionUpdateWithoutPlanningsInput>, Prisma.InstructionVersionUncheckedUpdateWithoutPlanningsInput>
}

export type InstructionVersionCreateWithoutUploadedByUserInput = {
  id?: string
  versionNumber?: number
  fileHash: string
  fileName: string
  filePath: string
  demandeur?: string | null
  chargeTotale: number
  dateDebut?: Date | string | null
  dateMEP?: Date | string | null
  dateValidation?: Date | string | null
  status?: string
  imputedBy?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  project: Prisma.ProjectCreateNestedOneWithoutVersionsInput
  collaborators?: Prisma.CollaboratorLineCreateNestedManyWithoutVersionInput
  plannings?: Prisma.PlanningLineCreateNestedManyWithoutVersionInput
}

export type InstructionVersionUncheckedCreateWithoutUploadedByUserInput = {
  id?: string
  projectId: string
  versionNumber?: number
  fileHash: string
  fileName: string
  filePath: string
  demandeur?: string | null
  chargeTotale: number
  dateDebut?: Date | string | null
  dateMEP?: Date | string | null
  dateValidation?: Date | string | null
  status?: string
  imputedBy?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  collaborators?: Prisma.CollaboratorLineUncheckedCreateNestedManyWithoutVersionInput
  plannings?: Prisma.PlanningLineUncheckedCreateNestedManyWithoutVersionInput
}

export type InstructionVersionCreateOrConnectWithoutUploadedByUserInput = {
  where: Prisma.InstructionVersionWhereUniqueInput
  create: Prisma.XOR<Prisma.InstructionVersionCreateWithoutUploadedByUserInput, Prisma.InstructionVersionUncheckedCreateWithoutUploadedByUserInput>
}

export type InstructionVersionCreateManyUploadedByUserInputEnvelope = {
  data: Prisma.InstructionVersionCreateManyUploadedByUserInput | Prisma.InstructionVersionCreateManyUploadedByUserInput[]
}

export type InstructionVersionUpsertWithWhereUniqueWithoutUploadedByUserInput = {
  where: Prisma.InstructionVersionWhereUniqueInput
  update: Prisma.XOR<Prisma.InstructionVersionUpdateWithoutUploadedByUserInput, Prisma.InstructionVersionUncheckedUpdateWithoutUploadedByUserInput>
  create: Prisma.XOR<Prisma.InstructionVersionCreateWithoutUploadedByUserInput, Prisma.InstructionVersionUncheckedCreateWithoutUploadedByUserInput>
}

export type InstructionVersionUpdateWithWhereUniqueWithoutUploadedByUserInput = {
  where: Prisma.InstructionVersionWhereUniqueInput
  data: Prisma.XOR<Prisma.InstructionVersionUpdateWithoutUploadedByUserInput, Prisma.InstructionVersionUncheckedUpdateWithoutUploadedByUserInput>
}

export type InstructionVersionUpdateManyWithWhereWithoutUploadedByUserInput = {
  where: Prisma.InstructionVersionScalarWhereInput
  data: Prisma.XOR<Prisma.InstructionVersionUpdateManyMutationInput, Prisma.InstructionVersionUncheckedUpdateManyWithoutUploadedByUserInput>
}

export type InstructionVersionScalarWhereInput = {
  AND?: Prisma.InstructionVersionScalarWhereInput | Prisma.InstructionVersionScalarWhereInput[]
  OR?: Prisma.InstructionVersionScalarWhereInput[]
  NOT?: Prisma.InstructionVersionScalarWhereInput | Prisma.InstructionVersionScalarWhereInput[]
  id?: Prisma.StringFilter<"InstructionVersion"> | string
  projectId?: Prisma.StringFilter<"InstructionVersion"> | string
  versionNumber?: Prisma.IntFilter<"InstructionVersion"> | number
  fileHash?: Prisma.StringFilter<"InstructionVersion"> | string
  fileName?: Prisma.StringFilter<"InstructionVersion"> | string
  filePath?: Prisma.StringFilter<"InstructionVersion"> | string
  demandeur?: Prisma.StringNullableFilter<"InstructionVersion"> | string | null
  chargeTotale?: Prisma.FloatFilter<"InstructionVersion"> | number
  dateDebut?: Prisma.DateTimeNullableFilter<"InstructionVersion"> | Date | string | null
  dateMEP?: Prisma.DateTimeNullableFilter<"InstructionVersion"> | Date | string | null
  dateValidation?: Prisma.DateTimeNullableFilter<"InstructionVersion"> | Date | string | null
  status?: Prisma.StringFilter<"InstructionVersion"> | string
  imputedBy?: Prisma.StringNullableFilter<"InstructionVersion"> | string | null
  uploadedBy?: Prisma.StringFilter<"InstructionVersion"> | string
  createdAt?: Prisma.DateTimeFilter<"InstructionVersion"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"InstructionVersion"> | Date | string
}

export type InstructionVersionCreateWithoutProjectInput = {
  id?: string
  versionNumber?: number
  fileHash: string
  fileName: string
  filePath: string
  demandeur?: string | null
  chargeTotale: number
  dateDebut?: Date | string | null
  dateMEP?: Date | string | null
  dateValidation?: Date | string | null
  status?: string
  imputedBy?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  collaborators?: Prisma.CollaboratorLineCreateNestedManyWithoutVersionInput
  plannings?: Prisma.PlanningLineCreateNestedManyWithoutVersionInput
  uploadedByUser: Prisma.UserCreateNestedOneWithoutUploadedVersionsInput
}

export type InstructionVersionUncheckedCreateWithoutProjectInput = {
  id?: string
  versionNumber?: number
  fileHash: string
  fileName: string
  filePath: string
  demandeur?: string | null
  chargeTotale: number
  dateDebut?: Date | string | null
  dateMEP?: Date | string | null
  dateValidation?: Date | string | null
  status?: string
  imputedBy?: string | null
  uploadedBy: string
  createdAt?: Date | string
  updatedAt?: Date | string
  collaborators?: Prisma.CollaboratorLineUncheckedCreateNestedManyWithoutVersionInput
  plannings?: Prisma.PlanningLineUncheckedCreateNestedManyWithoutVersionInput
}

export type InstructionVersionCreateOrConnectWithoutProjectInput = {
  where: Prisma.InstructionVersionWhereUniqueInput
  create: Prisma.XOR<Prisma.InstructionVersionCreateWithoutProjectInput, Prisma.InstructionVersionUncheckedCreateWithoutProjectInput>
}

export type InstructionVersionCreateManyProjectInputEnvelope = {
  data: Prisma.InstructionVersionCreateManyProjectInput | Prisma.InstructionVersionCreateManyProjectInput[]
}

export type InstructionVersionUpsertWithWhereUniqueWithoutProjectInput = {
  where: Prisma.InstructionVersionWhereUniqueInput
  update: Prisma.XOR<Prisma.InstructionVersionUpdateWithoutProjectInput, Prisma.InstructionVersionUncheckedUpdateWithoutProjectInput>
  create: Prisma.XOR<Prisma.InstructionVersionCreateWithoutProjectInput, Prisma.InstructionVersionUncheckedCreateWithoutProjectInput>
}

export type InstructionVersionUpdateWithWhereUniqueWithoutProjectInput = {
  where: Prisma.InstructionVersionWhereUniqueInput
  data: Prisma.XOR<Prisma.InstructionVersionUpdateWithoutProjectInput, Prisma.InstructionVersionUncheckedUpdateWithoutProjectInput>
}

export type InstructionVersionUpdateManyWithWhereWithoutProjectInput = {
  where: Prisma.InstructionVersionScalarWhereInput
  data: Prisma.XOR<Prisma.InstructionVersionUpdateManyMutationInput, Prisma.InstructionVersionUncheckedUpdateManyWithoutProjectInput>
}

export type InstructionVersionCreateWithoutCollaboratorsInput = {
  id?: string
  versionNumber?: number
  fileHash: string
  fileName: string
  filePath: string
  demandeur?: string | null
  chargeTotale: number
  dateDebut?: Date | string | null
  dateMEP?: Date | string | null
  dateValidation?: Date | string | null
  status?: string
  imputedBy?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  project: Prisma.ProjectCreateNestedOneWithoutVersionsInput
  plannings?: Prisma.PlanningLineCreateNestedManyWithoutVersionInput
  uploadedByUser: Prisma.UserCreateNestedOneWithoutUploadedVersionsInput
}

export type InstructionVersionUncheckedCreateWithoutCollaboratorsInput = {
  id?: string
  projectId: string
  versionNumber?: number
  fileHash: string
  fileName: string
  filePath: string
  demandeur?: string | null
  chargeTotale: number
  dateDebut?: Date | string | null
  dateMEP?: Date | string | null
  dateValidation?: Date | string | null
  status?: string
  imputedBy?: string | null
  uploadedBy: string
  createdAt?: Date | string
  updatedAt?: Date | string
  plannings?: Prisma.PlanningLineUncheckedCreateNestedManyWithoutVersionInput
}

export type InstructionVersionCreateOrConnectWithoutCollaboratorsInput = {
  where: Prisma.InstructionVersionWhereUniqueInput
  create: Prisma.XOR<Prisma.InstructionVersionCreateWithoutCollaboratorsInput, Prisma.InstructionVersionUncheckedCreateWithoutCollaboratorsInput>
}

export type InstructionVersionUpsertWithoutCollaboratorsInput = {
  update: Prisma.XOR<Prisma.InstructionVersionUpdateWithoutCollaboratorsInput, Prisma.InstructionVersionUncheckedUpdateWithoutCollaboratorsInput>
  create: Prisma.XOR<Prisma.InstructionVersionCreateWithoutCollaboratorsInput, Prisma.InstructionVersionUncheckedCreateWithoutCollaboratorsInput>
  where?: Prisma.InstructionVersionWhereInput
}

export type InstructionVersionUpdateToOneWithWhereWithoutCollaboratorsInput = {
  where?: Prisma.InstructionVersionWhereInput
  data: Prisma.XOR<Prisma.InstructionVersionUpdateWithoutCollaboratorsInput, Prisma.InstructionVersionUncheckedUpdateWithoutCollaboratorsInput>
}

export type InstructionVersionUpdateWithoutCollaboratorsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  versionNumber?: Prisma.IntFieldUpdateOperationsInput | number
  fileHash?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  filePath?: Prisma.StringFieldUpdateOperationsInput | string
  demandeur?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  chargeTotale?: Prisma.FloatFieldUpdateOperationsInput | number
  dateDebut?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateMEP?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateValidation?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  imputedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  project?: Prisma.ProjectUpdateOneRequiredWithoutVersionsNestedInput
  plannings?: Prisma.PlanningLineUpdateManyWithoutVersionNestedInput
  uploadedByUser?: Prisma.UserUpdateOneRequiredWithoutUploadedVersionsNestedInput
}

export type InstructionVersionUncheckedUpdateWithoutCollaboratorsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  projectId?: Prisma.StringFieldUpdateOperationsInput | string
  versionNumber?: Prisma.IntFieldUpdateOperationsInput | number
  fileHash?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  filePath?: Prisma.StringFieldUpdateOperationsInput | string
  demandeur?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  chargeTotale?: Prisma.FloatFieldUpdateOperationsInput | number
  dateDebut?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateMEP?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateValidation?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  imputedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  uploadedBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  plannings?: Prisma.PlanningLineUncheckedUpdateManyWithoutVersionNestedInput
}

export type InstructionVersionCreateWithoutPlanningsInput = {
  id?: string
  versionNumber?: number
  fileHash: string
  fileName: string
  filePath: string
  demandeur?: string | null
  chargeTotale: number
  dateDebut?: Date | string | null
  dateMEP?: Date | string | null
  dateValidation?: Date | string | null
  status?: string
  imputedBy?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  project: Prisma.ProjectCreateNestedOneWithoutVersionsInput
  collaborators?: Prisma.CollaboratorLineCreateNestedManyWithoutVersionInput
  uploadedByUser: Prisma.UserCreateNestedOneWithoutUploadedVersionsInput
}

export type InstructionVersionUncheckedCreateWithoutPlanningsInput = {
  id?: string
  projectId: string
  versionNumber?: number
  fileHash: string
  fileName: string
  filePath: string
  demandeur?: string | null
  chargeTotale: number
  dateDebut?: Date | string | null
  dateMEP?: Date | string | null
  dateValidation?: Date | string | null
  status?: string
  imputedBy?: string | null
  uploadedBy: string
  createdAt?: Date | string
  updatedAt?: Date | string
  collaborators?: Prisma.CollaboratorLineUncheckedCreateNestedManyWithoutVersionInput
}

export type InstructionVersionCreateOrConnectWithoutPlanningsInput = {
  where: Prisma.InstructionVersionWhereUniqueInput
  create: Prisma.XOR<Prisma.InstructionVersionCreateWithoutPlanningsInput, Prisma.InstructionVersionUncheckedCreateWithoutPlanningsInput>
}

export type InstructionVersionUpsertWithoutPlanningsInput = {
  update: Prisma.XOR<Prisma.InstructionVersionUpdateWithoutPlanningsInput, Prisma.InstructionVersionUncheckedUpdateWithoutPlanningsInput>
  create: Prisma.XOR<Prisma.InstructionVersionCreateWithoutPlanningsInput, Prisma.InstructionVersionUncheckedCreateWithoutPlanningsInput>
  where?: Prisma.InstructionVersionWhereInput
}

export type InstructionVersionUpdateToOneWithWhereWithoutPlanningsInput = {
  where?: Prisma.InstructionVersionWhereInput
  data: Prisma.XOR<Prisma.InstructionVersionUpdateWithoutPlanningsInput, Prisma.InstructionVersionUncheckedUpdateWithoutPlanningsInput>
}

export type InstructionVersionUpdateWithoutPlanningsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  versionNumber?: Prisma.IntFieldUpdateOperationsInput | number
  fileHash?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  filePath?: Prisma.StringFieldUpdateOperationsInput | string
  demandeur?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  chargeTotale?: Prisma.FloatFieldUpdateOperationsInput | number
  dateDebut?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateMEP?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateValidation?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  imputedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  project?: Prisma.ProjectUpdateOneRequiredWithoutVersionsNestedInput
  collaborators?: Prisma.CollaboratorLineUpdateManyWithoutVersionNestedInput
  uploadedByUser?: Prisma.UserUpdateOneRequiredWithoutUploadedVersionsNestedInput
}

export type InstructionVersionUncheckedUpdateWithoutPlanningsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  projectId?: Prisma.StringFieldUpdateOperationsInput | string
  versionNumber?: Prisma.IntFieldUpdateOperationsInput | number
  fileHash?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  filePath?: Prisma.StringFieldUpdateOperationsInput | string
  demandeur?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  chargeTotale?: Prisma.FloatFieldUpdateOperationsInput | number
  dateDebut?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateMEP?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateValidation?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  imputedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  uploadedBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  collaborators?: Prisma.CollaboratorLineUncheckedUpdateManyWithoutVersionNestedInput
}

export type InstructionVersionCreateManyUploadedByUserInput = {
  id?: string
  projectId: string
  versionNumber?: number
  fileHash: string
  fileName: string
  filePath: string
  demandeur?: string | null
  chargeTotale: number
  dateDebut?: Date | string | null
  dateMEP?: Date | string | null
  dateValidation?: Date | string | null
  status?: string
  imputedBy?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type InstructionVersionUpdateWithoutUploadedByUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  versionNumber?: Prisma.IntFieldUpdateOperationsInput | number
  fileHash?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  filePath?: Prisma.StringFieldUpdateOperationsInput | string
  demandeur?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  chargeTotale?: Prisma.FloatFieldUpdateOperationsInput | number
  dateDebut?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateMEP?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateValidation?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  imputedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  project?: Prisma.ProjectUpdateOneRequiredWithoutVersionsNestedInput
  collaborators?: Prisma.CollaboratorLineUpdateManyWithoutVersionNestedInput
  plannings?: Prisma.PlanningLineUpdateManyWithoutVersionNestedInput
}

export type InstructionVersionUncheckedUpdateWithoutUploadedByUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  projectId?: Prisma.StringFieldUpdateOperationsInput | string
  versionNumber?: Prisma.IntFieldUpdateOperationsInput | number
  fileHash?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  filePath?: Prisma.StringFieldUpdateOperationsInput | string
  demandeur?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  chargeTotale?: Prisma.FloatFieldUpdateOperationsInput | number
  dateDebut?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateMEP?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateValidation?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  imputedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  collaborators?: Prisma.CollaboratorLineUncheckedUpdateManyWithoutVersionNestedInput
  plannings?: Prisma.PlanningLineUncheckedUpdateManyWithoutVersionNestedInput
}

export type InstructionVersionUncheckedUpdateManyWithoutUploadedByUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  projectId?: Prisma.StringFieldUpdateOperationsInput | string
  versionNumber?: Prisma.IntFieldUpdateOperationsInput | number
  fileHash?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  filePath?: Prisma.StringFieldUpdateOperationsInput | string
  demandeur?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  chargeTotale?: Prisma.FloatFieldUpdateOperationsInput | number
  dateDebut?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateMEP?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateValidation?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  imputedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type InstructionVersionCreateManyProjectInput = {
  id?: string
  versionNumber?: number
  fileHash: string
  fileName: string
  filePath: string
  demandeur?: string | null
  chargeTotale: number
  dateDebut?: Date | string | null
  dateMEP?: Date | string | null
  dateValidation?: Date | string | null
  status?: string
  imputedBy?: string | null
  uploadedBy: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type InstructionVersionUpdateWithoutProjectInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  versionNumber?: Prisma.IntFieldUpdateOperationsInput | number
  fileHash?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  filePath?: Prisma.StringFieldUpdateOperationsInput | string
  demandeur?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  chargeTotale?: Prisma.FloatFieldUpdateOperationsInput | number
  dateDebut?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateMEP?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateValidation?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  imputedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  collaborators?: Prisma.CollaboratorLineUpdateManyWithoutVersionNestedInput
  plannings?: Prisma.PlanningLineUpdateManyWithoutVersionNestedInput
  uploadedByUser?: Prisma.UserUpdateOneRequiredWithoutUploadedVersionsNestedInput
}

export type InstructionVersionUncheckedUpdateWithoutProjectInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  versionNumber?: Prisma.IntFieldUpdateOperationsInput | number
  fileHash?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  filePath?: Prisma.StringFieldUpdateOperationsInput | string
  demandeur?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  chargeTotale?: Prisma.FloatFieldUpdateOperationsInput | number
  dateDebut?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateMEP?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateValidation?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  imputedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  uploadedBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  collaborators?: Prisma.CollaboratorLineUncheckedUpdateManyWithoutVersionNestedInput
  plannings?: Prisma.PlanningLineUncheckedUpdateManyWithoutVersionNestedInput
}

export type InstructionVersionUncheckedUpdateManyWithoutProjectInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  versionNumber?: Prisma.IntFieldUpdateOperationsInput | number
  fileHash?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  filePath?: Prisma.StringFieldUpdateOperationsInput | string
  demandeur?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  chargeTotale?: Prisma.FloatFieldUpdateOperationsInput | number
  dateDebut?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateMEP?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dateValidation?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  imputedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  uploadedBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}


/**
 * Count Type InstructionVersionCountOutputType
 */

export type InstructionVersionCountOutputType = {
  collaborators: number
  plannings: number
}

export type InstructionVersionCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  collaborators?: boolean | InstructionVersionCountOutputTypeCountCollaboratorsArgs
  plannings?: boolean | InstructionVersionCountOutputTypeCountPlanningsArgs
}

/**
 * InstructionVersionCountOutputType without action
 */
export type InstructionVersionCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the InstructionVersionCountOutputType
   */
  select?: Prisma.InstructionVersionCountOutputTypeSelect<ExtArgs> | null
}

/**
 * InstructionVersionCountOutputType without action
 */
export type InstructionVersionCountOutputTypeCountCollaboratorsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CollaboratorLineWhereInput
}

/**
 * InstructionVersionCountOutputType without action
 */
export type InstructionVersionCountOutputTypeCountPlanningsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.PlanningLineWhereInput
}


export type InstructionVersionSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  projectId?: boolean
  versionNumber?: boolean
  fileHash?: boolean
  fileName?: boolean
  filePath?: boolean
  demandeur?: boolean
  chargeTotale?: boolean
  dateDebut?: boolean
  dateMEP?: boolean
  dateValidation?: boolean
  status?: boolean
  imputedBy?: boolean
  uploadedBy?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  project?: boolean | Prisma.ProjectDefaultArgs<ExtArgs>
  collaborators?: boolean | Prisma.InstructionVersion$collaboratorsArgs<ExtArgs>
  plannings?: boolean | Prisma.InstructionVersion$planningsArgs<ExtArgs>
  uploadedByUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  _count?: boolean | Prisma.InstructionVersionCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["instructionVersion"]>

export type InstructionVersionSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  projectId?: boolean
  versionNumber?: boolean
  fileHash?: boolean
  fileName?: boolean
  filePath?: boolean
  demandeur?: boolean
  chargeTotale?: boolean
  dateDebut?: boolean
  dateMEP?: boolean
  dateValidation?: boolean
  status?: boolean
  imputedBy?: boolean
  uploadedBy?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  project?: boolean | Prisma.ProjectDefaultArgs<ExtArgs>
  uploadedByUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["instructionVersion"]>

export type InstructionVersionSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  projectId?: boolean
  versionNumber?: boolean
  fileHash?: boolean
  fileName?: boolean
  filePath?: boolean
  demandeur?: boolean
  chargeTotale?: boolean
  dateDebut?: boolean
  dateMEP?: boolean
  dateValidation?: boolean
  status?: boolean
  imputedBy?: boolean
  uploadedBy?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  project?: boolean | Prisma.ProjectDefaultArgs<ExtArgs>
  uploadedByUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["instructionVersion"]>

export type InstructionVersionSelectScalar = {
  id?: boolean
  projectId?: boolean
  versionNumber?: boolean
  fileHash?: boolean
  fileName?: boolean
  filePath?: boolean
  demandeur?: boolean
  chargeTotale?: boolean
  dateDebut?: boolean
  dateMEP?: boolean
  dateValidation?: boolean
  status?: boolean
  imputedBy?: boolean
  uploadedBy?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type InstructionVersionOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "projectId" | "versionNumber" | "fileHash" | "fileName" | "filePath" | "demandeur" | "chargeTotale" | "dateDebut" | "dateMEP" | "dateValidation" | "status" | "imputedBy" | "uploadedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["instructionVersion"]>
export type InstructionVersionInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  project?: boolean | Prisma.ProjectDefaultArgs<ExtArgs>
  collaborators?: boolean | Prisma.InstructionVersion$collaboratorsArgs<ExtArgs>
  plannings?: boolean | Prisma.InstructionVersion$planningsArgs<ExtArgs>
  uploadedByUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  _count?: boolean | Prisma.InstructionVersionCountOutputTypeDefaultArgs<ExtArgs>
}
export type InstructionVersionIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  project?: boolean | Prisma.ProjectDefaultArgs<ExtArgs>
  uploadedByUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}
export type InstructionVersionIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  project?: boolean | Prisma.ProjectDefaultArgs<ExtArgs>
  uploadedByUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}

export type $InstructionVersionPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "InstructionVersion"
  objects: {
    project: Prisma.$ProjectPayload<ExtArgs>
    collaborators: Prisma.$CollaboratorLinePayload<ExtArgs>[]
    plannings: Prisma.$PlanningLinePayload<ExtArgs>[]
    uploadedByUser: Prisma.$UserPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    projectId: string
    versionNumber: number
    fileHash: string
    fileName: string
    filePath: string
    demandeur: string | null
    chargeTotale: number
    dateDebut: Date | null
    dateMEP: Date | null
    dateValidation: Date | null
    status: string
    imputedBy: string | null
    uploadedBy: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["instructionVersion"]>
  composites: {}
}

export type InstructionVersionGetPayload<S extends boolean | null | undefined | InstructionVersionDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$InstructionVersionPayload, S>

export type InstructionVersionCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<InstructionVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: InstructionVersionCountAggregateInputType | true
  }

export interface InstructionVersionDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstructionVersion'], meta: { name: 'InstructionVersion' } }
  /**
   * Find zero or one InstructionVersion that matches the filter.
   * @param {InstructionVersionFindUniqueArgs} args - Arguments to find a InstructionVersion
   * @example
   * // Get one InstructionVersion
   * const instructionVersion = await prisma.instructionVersion.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends InstructionVersionFindUniqueArgs>(args: Prisma.SelectSubset<T, InstructionVersionFindUniqueArgs<ExtArgs>>): Prisma.Prisma__InstructionVersionClient<runtime.Types.Result.GetResult<Prisma.$InstructionVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one InstructionVersion that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {InstructionVersionFindUniqueOrThrowArgs} args - Arguments to find a InstructionVersion
   * @example
   * // Get one InstructionVersion
   * const instructionVersion = await prisma.instructionVersion.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends InstructionVersionFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, InstructionVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__InstructionVersionClient<runtime.Types.Result.GetResult<Prisma.$InstructionVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first InstructionVersion that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {InstructionVersionFindFirstArgs} args - Arguments to find a InstructionVersion
   * @example
   * // Get one InstructionVersion
   * const instructionVersion = await prisma.instructionVersion.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends InstructionVersionFindFirstArgs>(args?: Prisma.SelectSubset<T, InstructionVersionFindFirstArgs<ExtArgs>>): Prisma.Prisma__InstructionVersionClient<runtime.Types.Result.GetResult<Prisma.$InstructionVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first InstructionVersion that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {InstructionVersionFindFirstOrThrowArgs} args - Arguments to find a InstructionVersion
   * @example
   * // Get one InstructionVersion
   * const instructionVersion = await prisma.instructionVersion.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends InstructionVersionFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, InstructionVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__InstructionVersionClient<runtime.Types.Result.GetResult<Prisma.$InstructionVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more InstructionVersions that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {InstructionVersionFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all InstructionVersions
   * const instructionVersions = await prisma.instructionVersion.findMany()
   * 
   * // Get first 10 InstructionVersions
   * const instructionVersions = await prisma.instructionVersion.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const instructionVersionWithIdOnly = await prisma.instructionVersion.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends InstructionVersionFindManyArgs>(args?: Prisma.SelectSubset<T, InstructionVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$InstructionVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a InstructionVersion.
   * @param {InstructionVersionCreateArgs} args - Arguments to create a InstructionVersion.
   * @example
   * // Create one InstructionVersion
   * const InstructionVersion = await prisma.instructionVersion.create({
   *   data: {
   *     // ... data to create a InstructionVersion
   *   }
   * })
   * 
   */
  create<T extends InstructionVersionCreateArgs>(args: Prisma.SelectSubset<T, InstructionVersionCreateArgs<ExtArgs>>): Prisma.Prisma__InstructionVersionClient<runtime.Types.Result.GetResult<Prisma.$InstructionVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many InstructionVersions.
   * @param {InstructionVersionCreateManyArgs} args - Arguments to create many InstructionVersions.
   * @example
   * // Create many InstructionVersions
   * const instructionVersion = await prisma.instructionVersion.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends InstructionVersionCreateManyArgs>(args?: Prisma.SelectSubset<T, InstructionVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many InstructionVersions and returns the data saved in the database.
   * @param {InstructionVersionCreateManyAndReturnArgs} args - Arguments to create many InstructionVersions.
   * @example
   * // Create many InstructionVersions
   * const instructionVersion = await prisma.instructionVersion.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many InstructionVersions and only return the `id`
   * const instructionVersionWithIdOnly = await prisma.instructionVersion.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends InstructionVersionCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, InstructionVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$InstructionVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a InstructionVersion.
   * @param {InstructionVersionDeleteArgs} args - Arguments to delete one InstructionVersion.
   * @example
   * // Delete one InstructionVersion
   * const InstructionVersion = await prisma.instructionVersion.delete({
   *   where: {
   *     // ... filter to delete one InstructionVersion
   *   }
   * })
   * 
   */
  delete<T extends InstructionVersionDeleteArgs>(args: Prisma.SelectSubset<T, InstructionVersionDeleteArgs<ExtArgs>>): Prisma.Prisma__InstructionVersionClient<runtime.Types.Result.GetResult<Prisma.$InstructionVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one InstructionVersion.
   * @param {InstructionVersionUpdateArgs} args - Arguments to update one InstructionVersion.
   * @example
   * // Update one InstructionVersion
   * const instructionVersion = await prisma.instructionVersion.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends InstructionVersionUpdateArgs>(args: Prisma.SelectSubset<T, InstructionVersionUpdateArgs<ExtArgs>>): Prisma.Prisma__InstructionVersionClient<runtime.Types.Result.GetResult<Prisma.$InstructionVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more InstructionVersions.
   * @param {InstructionVersionDeleteManyArgs} args - Arguments to filter InstructionVersions to delete.
   * @example
   * // Delete a few InstructionVersions
   * const { count } = await prisma.instructionVersion.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends InstructionVersionDeleteManyArgs>(args?: Prisma.SelectSubset<T, InstructionVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more InstructionVersions.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {InstructionVersionUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many InstructionVersions
   * const instructionVersion = await prisma.instructionVersion.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends InstructionVersionUpdateManyArgs>(args: Prisma.SelectSubset<T, InstructionVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more InstructionVersions and returns the data updated in the database.
   * @param {InstructionVersionUpdateManyAndReturnArgs} args - Arguments to update many InstructionVersions.
   * @example
   * // Update many InstructionVersions
   * const instructionVersion = await prisma.instructionVersion.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more InstructionVersions and only return the `id`
   * const instructionVersionWithIdOnly = await prisma.instructionVersion.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends InstructionVersionUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, InstructionVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$InstructionVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one InstructionVersion.
   * @param {InstructionVersionUpsertArgs} args - Arguments to update or create a InstructionVersion.
   * @example
   * // Update or create a InstructionVersion
   * const instructionVersion = await prisma.instructionVersion.upsert({
   *   create: {
   *     // ... data to create a InstructionVersion
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the InstructionVersion we want to update
   *   }
   * })
   */
  upsert<T extends InstructionVersionUpsertArgs>(args: Prisma.SelectSubset<T, InstructionVersionUpsertArgs<ExtArgs>>): Prisma.Prisma__InstructionVersionClient<runtime.Types.Result.GetResult<Prisma.$InstructionVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of InstructionVersions.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {InstructionVersionCountArgs} args - Arguments to filter InstructionVersions to count.
   * @example
   * // Count the number of InstructionVersions
   * const count = await prisma.instructionVersion.count({
   *   where: {
   *     // ... the filter for the InstructionVersions we want to count
   *   }
   * })
  **/
  count<T extends InstructionVersionCountArgs>(
    args?: Prisma.Subset<T, InstructionVersionCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], InstructionVersionCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a InstructionVersion.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {InstructionVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends InstructionVersionAggregateArgs>(args: Prisma.Subset<T, InstructionVersionAggregateArgs>): Prisma.PrismaPromise<GetInstructionVersionAggregateType<T>>

  /**
   * Group by InstructionVersion.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {InstructionVersionGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends InstructionVersionGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: InstructionVersionGroupByArgs['orderBy'] }
      : { orderBy?: InstructionVersionGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, InstructionVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstructionVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the InstructionVersion model
 */
readonly fields: InstructionVersionFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for InstructionVersion.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__InstructionVersionClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  project<T extends Prisma.ProjectDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ProjectDefaultArgs<ExtArgs>>): Prisma.Prisma__ProjectClient<runtime.Types.Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  collaborators<T extends Prisma.InstructionVersion$collaboratorsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.InstructionVersion$collaboratorsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CollaboratorLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  plannings<T extends Prisma.InstructionVersion$planningsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.InstructionVersion$planningsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PlanningLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  uploadedByUser<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the InstructionVersion model
 */
export interface InstructionVersionFieldRefs {
  readonly id: Prisma.FieldRef<"InstructionVersion", 'String'>
  readonly projectId: Prisma.FieldRef<"InstructionVersion", 'String'>
  readonly versionNumber: Prisma.FieldRef<"InstructionVersion", 'Int'>
  readonly fileHash: Prisma.FieldRef<"InstructionVersion", 'String'>
  readonly fileName: Prisma.FieldRef<"InstructionVersion", 'String'>
  readonly filePath: Prisma.FieldRef<"InstructionVersion", 'String'>
  readonly demandeur: Prisma.FieldRef<"InstructionVersion", 'String'>
  readonly chargeTotale: Prisma.FieldRef<"InstructionVersion", 'Float'>
  readonly dateDebut: Prisma.FieldRef<"InstructionVersion", 'DateTime'>
  readonly dateMEP: Prisma.FieldRef<"InstructionVersion", 'DateTime'>
  readonly dateValidation: Prisma.FieldRef<"InstructionVersion", 'DateTime'>
  readonly status: Prisma.FieldRef<"InstructionVersion", 'String'>
  readonly imputedBy: Prisma.FieldRef<"InstructionVersion", 'String'>
  readonly uploadedBy: Prisma.FieldRef<"InstructionVersion", 'String'>
  readonly createdAt: Prisma.FieldRef<"InstructionVersion", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"InstructionVersion", 'DateTime'>
}
    

// Custom InputTypes
/**
 * InstructionVersion findUnique
 */
export type InstructionVersionFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the InstructionVersion
   */
  select?: Prisma.InstructionVersionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the InstructionVersion
   */
  omit?: Prisma.InstructionVersionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.InstructionVersionInclude<ExtArgs> | null
  /**
   * Filter, which InstructionVersion to fetch.
   */
  where: Prisma.InstructionVersionWhereUniqueInput
}

/**
 * InstructionVersion findUniqueOrThrow
 */
export type InstructionVersionFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the InstructionVersion
   */
  select?: Prisma.InstructionVersionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the InstructionVersion
   */
  omit?: Prisma.InstructionVersionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.InstructionVersionInclude<ExtArgs> | null
  /**
   * Filter, which InstructionVersion to fetch.
   */
  where: Prisma.InstructionVersionWhereUniqueInput
}

/**
 * InstructionVersion findFirst
 */
export type InstructionVersionFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the InstructionVersion
   */
  select?: Prisma.InstructionVersionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the InstructionVersion
   */
  omit?: Prisma.InstructionVersionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.InstructionVersionInclude<ExtArgs> | null
  /**
   * Filter, which InstructionVersion to fetch.
   */
  where?: Prisma.InstructionVersionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of InstructionVersions to fetch.
   */
  orderBy?: Prisma.InstructionVersionOrderByWithRelationInput | Prisma.InstructionVersionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for InstructionVersions.
   */
  cursor?: Prisma.InstructionVersionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` InstructionVersions from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` InstructionVersions.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of InstructionVersions.
   */
  distinct?: Prisma.InstructionVersionScalarFieldEnum | Prisma.InstructionVersionScalarFieldEnum[]
}

/**
 * InstructionVersion findFirstOrThrow
 */
export type InstructionVersionFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the InstructionVersion
   */
  select?: Prisma.InstructionVersionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the InstructionVersion
   */
  omit?: Prisma.InstructionVersionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.InstructionVersionInclude<ExtArgs> | null
  /**
   * Filter, which InstructionVersion to fetch.
   */
  where?: Prisma.InstructionVersionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of InstructionVersions to fetch.
   */
  orderBy?: Prisma.InstructionVersionOrderByWithRelationInput | Prisma.InstructionVersionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for InstructionVersions.
   */
  cursor?: Prisma.InstructionVersionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` InstructionVersions from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` InstructionVersions.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of InstructionVersions.
   */
  distinct?: Prisma.InstructionVersionScalarFieldEnum | Prisma.InstructionVersionScalarFieldEnum[]
}

/**
 * InstructionVersion findMany
 */
export type InstructionVersionFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the InstructionVersion
   */
  select?: Prisma.InstructionVersionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the InstructionVersion
   */
  omit?: Prisma.InstructionVersionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.InstructionVersionInclude<ExtArgs> | null
  /**
   * Filter, which InstructionVersions to fetch.
   */
  where?: Prisma.InstructionVersionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of InstructionVersions to fetch.
   */
  orderBy?: Prisma.InstructionVersionOrderByWithRelationInput | Prisma.InstructionVersionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing InstructionVersions.
   */
  cursor?: Prisma.InstructionVersionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` InstructionVersions from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` InstructionVersions.
   */
  skip?: number
  distinct?: Prisma.InstructionVersionScalarFieldEnum | Prisma.InstructionVersionScalarFieldEnum[]
}

/**
 * InstructionVersion create
 */
export type InstructionVersionCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the InstructionVersion
   */
  select?: Prisma.InstructionVersionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the InstructionVersion
   */
  omit?: Prisma.InstructionVersionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.InstructionVersionInclude<ExtArgs> | null
  /**
   * The data needed to create a InstructionVersion.
   */
  data: Prisma.XOR<Prisma.InstructionVersionCreateInput, Prisma.InstructionVersionUncheckedCreateInput>
}

/**
 * InstructionVersion createMany
 */
export type InstructionVersionCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many InstructionVersions.
   */
  data: Prisma.InstructionVersionCreateManyInput | Prisma.InstructionVersionCreateManyInput[]
}

/**
 * InstructionVersion createManyAndReturn
 */
export type InstructionVersionCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the InstructionVersion
   */
  select?: Prisma.InstructionVersionSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the InstructionVersion
   */
  omit?: Prisma.InstructionVersionOmit<ExtArgs> | null
  /**
   * The data used to create many InstructionVersions.
   */
  data: Prisma.InstructionVersionCreateManyInput | Prisma.InstructionVersionCreateManyInput[]
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.InstructionVersionIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * InstructionVersion update
 */
export type InstructionVersionUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the InstructionVersion
   */
  select?: Prisma.InstructionVersionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the InstructionVersion
   */
  omit?: Prisma.InstructionVersionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.InstructionVersionInclude<ExtArgs> | null
  /**
   * The data needed to update a InstructionVersion.
   */
  data: Prisma.XOR<Prisma.InstructionVersionUpdateInput, Prisma.InstructionVersionUncheckedUpdateInput>
  /**
   * Choose, which InstructionVersion to update.
   */
  where: Prisma.InstructionVersionWhereUniqueInput
}

/**
 * InstructionVersion updateMany
 */
export type InstructionVersionUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update InstructionVersions.
   */
  data: Prisma.XOR<Prisma.InstructionVersionUpdateManyMutationInput, Prisma.InstructionVersionUncheckedUpdateManyInput>
  /**
   * Filter which InstructionVersions to update
   */
  where?: Prisma.InstructionVersionWhereInput
  /**
   * Limit how many InstructionVersions to update.
   */
  limit?: number
}

/**
 * InstructionVersion updateManyAndReturn
 */
export type InstructionVersionUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the InstructionVersion
   */
  select?: Prisma.InstructionVersionSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the InstructionVersion
   */
  omit?: Prisma.InstructionVersionOmit<ExtArgs> | null
  /**
   * The data used to update InstructionVersions.
   */
  data: Prisma.XOR<Prisma.InstructionVersionUpdateManyMutationInput, Prisma.InstructionVersionUncheckedUpdateManyInput>
  /**
   * Filter which InstructionVersions to update
   */
  where?: Prisma.InstructionVersionWhereInput
  /**
   * Limit how many InstructionVersions to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.InstructionVersionIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * InstructionVersion upsert
 */
export type InstructionVersionUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the InstructionVersion
   */
  select?: Prisma.InstructionVersionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the InstructionVersion
   */
  omit?: Prisma.InstructionVersionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.InstructionVersionInclude<ExtArgs> | null
  /**
   * The filter to search for the InstructionVersion to update in case it exists.
   */
  where: Prisma.InstructionVersionWhereUniqueInput
  /**
   * In case the InstructionVersion found by the `where` argument doesn't exist, create a new InstructionVersion with this data.
   */
  create: Prisma.XOR<Prisma.InstructionVersionCreateInput, Prisma.InstructionVersionUncheckedCreateInput>
  /**
   * In case the InstructionVersion was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.InstructionVersionUpdateInput, Prisma.InstructionVersionUncheckedUpdateInput>
}

/**
 * InstructionVersion delete
 */
export type InstructionVersionDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the InstructionVersion
   */
  select?: Prisma.InstructionVersionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the InstructionVersion
   */
  omit?: Prisma.InstructionVersionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.InstructionVersionInclude<ExtArgs> | null
  /**
   * Filter which InstructionVersion to delete.
   */
  where: Prisma.InstructionVersionWhereUniqueInput
}

/**
 * InstructionVersion deleteMany
 */
export type InstructionVersionDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which InstructionVersions to delete
   */
  where?: Prisma.InstructionVersionWhereInput
  /**
   * Limit how many InstructionVersions to delete.
   */
  limit?: number
}

/**
 * InstructionVersion.collaborators
 */
export type InstructionVersion$collaboratorsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CollaboratorLine
   */
  select?: Prisma.CollaboratorLineSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CollaboratorLine
   */
  omit?: Prisma.CollaboratorLineOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CollaboratorLineInclude<ExtArgs> | null
  where?: Prisma.CollaboratorLineWhereInput
  orderBy?: Prisma.CollaboratorLineOrderByWithRelationInput | Prisma.CollaboratorLineOrderByWithRelationInput[]
  cursor?: Prisma.CollaboratorLineWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.CollaboratorLineScalarFieldEnum | Prisma.CollaboratorLineScalarFieldEnum[]
}

/**
 * InstructionVersion.plannings
 */
export type InstructionVersion$planningsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PlanningLine
   */
  select?: Prisma.PlanningLineSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PlanningLine
   */
  omit?: Prisma.PlanningLineOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PlanningLineInclude<ExtArgs> | null
  where?: Prisma.PlanningLineWhereInput
  orderBy?: Prisma.PlanningLineOrderByWithRelationInput | Prisma.PlanningLineOrderByWithRelationInput[]
  cursor?: Prisma.PlanningLineWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.PlanningLineScalarFieldEnum | Prisma.PlanningLineScalarFieldEnum[]
}

/**
 * InstructionVersion without action
 */
export type InstructionVersionDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the InstructionVersion
   */
  select?: Prisma.InstructionVersionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the InstructionVersion
   */
  omit?: Prisma.InstructionVersionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.InstructionVersionInclude<ExtArgs> | null
}
